# -*- coding: utf-8 -*-
"""seven.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CZiN4fojAMxuBEVdCDF19W4SO7qD9qrH

---

### Practice with dataframes and split-apply combine

- Pandas [dataframes](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html) are very common structures for representing data. We will practice using them in this notebook. You will do more complex things with DataFrames in the future. This first notebook emphasizes the basics.

- [Split-apply-combine](https://pandas.pydata.org/docs/user_guide/groupby.html) is a fundamental operation for analyzing many kinds of business data
- We will practice split-apply-combine via the pandas `group_by` function in this notebook.


##### A few important instructions
- Your functions should work on samples of the data
- To test your code, I will sample random rows from the data frame and ensure that your code returns the correct answer for that subset of the data. 
- For instance, if you are asked to write a function called `num_observations` that returns the number of observations in a dataframe, it should return 7 for a dataframe `df1` that has 7 rows and 9 for another dataframe `df2` that has 9 rows. You can test and other things this yourself!

### Start off by reading in a dataset about businesses in Boulder

- You will need to upload the file `boulderbusiness.csv` to collab.
"""

import pandas as pd 
from pandas import DataFrame

filename = "boulderbusiness.csv"

df = pd.read_csv(filename)

def num_observations(input_df: DataFrame) -> int:
    '''
    Each row in a dataframe is called an "observation"
    
    Input:
    - input_df: a pandas DataFrame
    
    Output:
    - The number of observations in the dataframe
    - The output should be an integer
    '''
    # YOUR CODE HERE
    raise NotImplementedError()

assert type(num_observations(df)) == int, "num_observations should return an int"

# There is a one point hidden test here.
# The test checks if your num_observations returns 
# the number of observations in a dataframe you have not
# seen yet. Your code should be able to return the
# number of observations in different dataframes

def ncolumns(input_df: DataFrame) -> int:
    '''
    Return the number of columns in the 
    input_df parameter
    
    Input:
    - input_df: a pandas DataFrame
    
    Output:
    - The columns in the dataframe
    '''
    # YOUR CODE HERE
    raise NotImplementedError()

# this is a one point test
assert type(ncolumns(df)) == int, "ncolumns should return an int"

# There is a one point hidden test here.
# The test checks if your ncolumns function returns 
# the number of columns in an unseen dataframe

"""### Inspecting the data

- Often, after loading data into pandas you want to inspect it manually
- What do you think the `entitytype` field means in the dataframe?
- Hint: you may need to call "columns" to find this column name
- Hint: use `df["A"]` to see the series for column A
"""

def num_entity_types(input_df: DataFrame) -> int:
    '''
    
    The pd.unique method returns the number of unique items
    in a pandas series.
    
    Use the unique method to get the total number of distinct 
    entity types in the dataframe
    
    Input:
    - input_df: a pandas DataFrame
    
    Output:
    - The number of total unique entity types in the 
      dataset.
    '''
    # YOUR CODE HERE
    raise NotImplementedError()

# this is a two point hidden test.
# it checks that your `num_entity_types` is correct
# for a subset of the data

def group_by_entity_type_and_count(input_df: DataFrame) -> DataFrame:
    '''
    
    In this function you will practice grouping data
    and applying an aggregation. To complete the function
    
    - Take an input data frame
    - Group it by entity type
    - Call the "count" aggregation function to count up the number of entity types in 
      each group
    
    Input:
    - input_df: a pandas DataFrame
    
    Output:
    - output_df: a pandas DataFrame, with data grouped by entity type showing the
                 count of entities in each group
                 
    You can call reset_index if you want, but you don't have to
    '''
    # YOUR CODE HERE
    raise NotImplementedError()

# this is a one point test

# call the function
type_and_count = group_by_entity_type_and_count(df)

# reset the index
reset = type_and_count.reset_index().set_index("entitytype")

# check that there are 15878 corporations in the result
assert reset.loc["Corporation"]["entityid"] == 15878, "There are 15878 total corporations registered in Boulder"

# this is a two point hidden test

# The test checks if your group_by_entity_type_and_count function
# can also work for an unseen dataframe.
# To pass this test, check your own code to ensure that your function
# works for different inputs

"""### Challenge problem
- This problem is worth one point
- It is a little harder than some of the other ones in this notebook. You will have to do a little bit of research on the pandas API on your own to solve the problem.
- If you get everything right but the challenge you will get a 9/10 on the HW

To do the challenge, you need to make sure the entityformdate is correctly represented as a date to the problem. Just run the line of code below to ensure the date is correctly formatted.
"""

df["entityformdate"] = pd.to_datetime(df["entityformdate"])

"""Ok! Now you are ready for the challenge problem. Using groupby and consulting the [pandas documentation](https://pandas.pydata.org/docs/user_guide/groupby.html#named-aggregation), write a function that takes a dataframe and entity type as input and returns the earliest formation date for the businesses in the group. For instance, the oldest "Nonprofit Corporation" in Boulder (according to this dataset) was formed on 1871-03-03. So you should return 1871-03-03 (a Timestamp) if the input was this dataframe and the entity type "Nonprofit Corporation". Timestamps are just pandas way of representing dates; see the docs below. 

#### Learn to read the docs!! 

Working from documentation is a *really* important skill. It's not like any class can teach you every feature of a language or library. A class like BAIM 3220 can get you up and running. But you will need to consult documentation to learn how to use new features as you use Python (or pandas) in the future.
"""

from pandas import Timestamp
# see https://pandas.pydata.org/docs/reference/api/pandas.Timestamp.html

def challenge(input_dataframe: DataFrame, entitytype: str) -> Timestamp:
    # YOUR CODE HERE
    raise NotImplementedError()

# this is an ungraded test to show you the expected outcome from the function. The hidden test is very similar
assert df.groupby("entitytype")["entityformdate"].min()["Nonprofit Corporation"].year == 1871

# this is a 1 point hidden test